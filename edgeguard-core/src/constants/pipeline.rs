//! Pipeline Processing Constants
//!
//! This module defines constants for the event processing pipeline including
//! stage limits, buffer sizes, time windows, and numerical thresholds used
//! in aggregation and validation stages.

// ===== STAGE AND ROUTING LIMITS =====

/// Maximum number of stages in a pipeline.
/// 
/// Limits pipeline complexity to prevent excessive memory usage
/// and maintain predictable performance. 16 stages provides
/// sufficient flexibility for most IoT processing needs.
/// 
/// Source: Balance between flexibility and embedded constraints
pub const MAX_PIPELINE_STAGES: usize = 16;

/// Maximum number of routes in router stage.
/// 
/// Supports routing to different handlers based on sensor type.
/// 8 routes covers all standard sensor types with room for custom.
/// 
/// Source: Number of SensorType enum variants plus margin
pub const MAX_ROUTES: usize = 8;

/// Maximum number of sensor pairs for cross-validation.
/// 
/// Limits cross-sensor validation complexity. 4 pairs allows
/// temperature-humidity, pressure-altitude, and 2 custom pairs.
/// 
/// Source: Common sensor correlation patterns
pub const MAX_SENSOR_PAIRS: usize = 4;

/// Maximum events in stage output buffer.
/// 
/// Intermediate buffer for events generated by a stage.
/// Sized to handle reasonable fan-out without excessive memory.
/// 
/// Source: Empirical testing of stage behaviors
pub const MAX_STAGE_OUTPUT_EVENTS: usize = 16;

// ===== QUEUE AND BUFFER SIZES =====

/// Maximum window size for aggregation.
/// 
/// Limits memory usage for windowed aggregation operations.
/// 100 samples provides good statistical properties while
/// remaining memory-efficient.
/// 
/// Source: Statistical analysis requirements
pub const MAX_AGGREGATION_WINDOW: usize = 100;

/// Default queue size for low-memory devices (32KB systems).
/// 
/// Suitable for microcontrollers with limited RAM.
/// 256 events * ~64 bytes/event â‰ˆ 16KB.
/// 
/// Source: ESP32, STM32 memory constraints
pub const DEFAULT_QUEUE_SIZE_SMALL: usize = 256;

/// Default queue size for standard IoT devices.
/// 
/// Balanced size for typical edge devices.
/// 1024 events provides good buffering without excessive memory.
/// 
/// Source: Raspberry Pi Zero, industrial IoT devices
pub const DEFAULT_QUEUE_SIZE_MEDIUM: usize = 1024;

/// Default queue size for high-throughput gateways.
/// 
/// Larger buffer for aggregation points and gateways.
/// 4096 events handles burst traffic and network delays.
/// 
/// Source: Industrial gateway requirements
pub const DEFAULT_QUEUE_SIZE_LARGE: usize = 4096;

// ===== TIME WINDOW CONSTANTS =====

/// Default time window for cross-validation (milliseconds).
/// 
/// Readings must be within this window to be correlated.
/// 5 seconds allows for sensor timing variations while
/// ensuring readings represent same environmental state.
/// 
/// Source: Sensor sampling rate analysis
pub const DEFAULT_TIME_WINDOW_MS: u32 = 5000;

/// Default aggregation interval (milliseconds).
/// 
/// Standard window for time-based aggregation.
/// 1 second provides good balance between responsiveness
/// and meaningful statistics.
/// 
/// Source: Common IoT reporting intervals
pub const DEFAULT_AGGREGATION_INTERVAL_MS: u32 = 1000;

/// Cross-validation time window (milliseconds).
/// 
/// Maximum time difference between correlated sensor readings.
/// Same as DEFAULT_TIME_WINDOW_MS but semantically specific.
/// 
/// Source: Environmental state coherence time
pub const CROSS_VALIDATION_TIME_WINDOW_MS: u32 = 5000;

// ===== PROCESSING LIMITS =====

/// Maximum events to process in a single batch.
/// 
/// Prevents runaway processing that could block the system.
/// 100 events takes ~10ms on typical embedded processors.
/// 
/// Source: Real-time processing constraints
pub const MAX_BATCH_PROCESS_EVENTS: usize = 100;

/// Stage output buffer size.
/// 
/// Size of intermediate buffer for stage outputs.
/// Must handle reasonable fan-out (e.g., validation events).
/// 
/// Source: Maximum expected event multiplication
pub const STAGE_OUTPUT_BUFFER_SIZE: usize = 16;

/// Maximum recent readings for cross-validation.
/// 
/// History size for correlating readings across sensors.
/// 16 entries * 8 sensor types = 128 readings cached.
/// 
/// Source: Memory budget for validation state
pub const MAX_RECENT_READINGS: usize = 16;

// ===== NUMERICAL CONSTANTS =====

/// Epsilon for square root convergence (Newton's method).
/// 
/// Convergence threshold for iterative square root calculation.
/// 0.001 provides 0.1% accuracy, sufficient for sensor data.
/// 
/// Source: Sensor measurement precision limits
pub const SQRT_EPSILON: f32 = 0.001;

/// Maximum iterations for square root calculation.
/// 
/// Prevents infinite loops in Newton's method.
/// 10 iterations typically converges to machine precision.
/// 
/// Source: Numerical analysis of Newton's method
pub const SQRT_MAX_ITERATIONS: usize = 10;

/// Threshold for using bubble sort vs. advanced sorting.
/// 
/// Below this size, bubble sort is efficient for median calculation.
/// Modern processors handle small arrays efficiently with simple algorithms.
/// 
/// Source: Algorithm performance benchmarks
pub const MEDIAN_SORT_THRESHOLD: usize = 100;

/// Epsilon for floating-point comparisons.
/// 
/// Threshold for considering floating-point values equal.
/// Accounts for rounding errors in calculations.
/// 
/// Source: IEEE 754 single precision limits
pub const FLOAT_EPSILON: f32 = 1e-6;

/// Divisor for median of even-length arrays.
/// 
/// Used to average middle two values: (a + b) / 2.0
/// Explicit constant for clarity in calculations.
/// 
/// Source: Mathematical definition of median
pub const MEDIAN_EVEN_DIVISOR: f32 = 2.0;

// ===== STATISTICAL CONSTANTS =====

/// Minimum samples required for standard deviation.
/// 
/// Need at least 2 samples to calculate meaningful variance.
/// Below this, standard deviation is undefined or zero.
/// 
/// Source: Statistical theory
pub const MIN_STDDEV_SAMPLES: usize = 2;

/// Divisor offset for sample variance calculation.
/// 
/// Use N-1 (Bessel's correction) for unbiased sample variance.
/// Subtracting 1 corrects for using sample mean instead of population mean.
/// 
/// Source: Bessel's correction for sample variance
pub const VARIANCE_DIVISOR_OFFSET: usize = 1;

/// Factor for standard deviation calculation.
/// 
/// Divisor used in Newton's method for square root: (x + variance/x) / 2.0
/// The 2.0 factor comes from the Newton-Raphson formula.
/// 
/// Source: Newton's method for square root
pub const NEWTON_SQRT_DIVISOR: f32 = 2.0;

// ===== CROSS-VALIDATION CONSTANTS =====

/// Margin for dew point validation.
/// 
/// Dew point must be less than or equal to temperature (physics constraint).
/// Zero margin enforces strict physical laws - no tolerance.
/// 
/// Source: Thermodynamic constraints
pub const DEW_POINT_VALIDATION_MARGIN: f32 = 0.0;

/// Default deviation threshold for cross-validation.
/// 
/// Maximum allowed deviation between correlated sensors.
/// Can be overridden per validation type.
/// 
/// Source: Typical sensor accuracy specifications
pub const DEFAULT_DEVIATION_THRESHOLD: f32 = 0.1;

// ===== INITIAL VALUES =====

/// Initial value for minimum aggregation.
/// 
/// Starting value for finding minimum in a window.
/// Must be larger than any possible sensor reading.
/// 
/// Source: f32::INFINITY constant
pub const AGG_MIN_INITIAL: f32 = f32::INFINITY;

/// Initial value for maximum aggregation.
/// 
/// Starting value for finding maximum in a window.
/// Must be smaller than any possible sensor reading.
/// 
/// Source: f32::NEG_INFINITY constant
pub const AGG_MAX_INITIAL: f32 = f32::NEG_INFINITY;

/// Empty buffer value for aggregation results.
/// 
/// Returned when calculating statistics on empty buffer.
/// Zero is reasonable default for sum, mean, etc.
/// 
/// Source: Mathematical convention
pub const EMPTY_BUFFER_VALUE: f32 = 0.0;

/// Default interval when no timestamps available.
/// 
/// Used when calculating intervals with single timestamp.
/// Zero indicates no interval can be calculated.
/// 
/// Source: Logical default for undefined interval
pub const DEFAULT_INTERVAL_MS: u16 = 0;